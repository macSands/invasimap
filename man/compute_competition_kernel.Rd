% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_competition_kernel.R
\name{compute_competition_kernel}
\alias{compute_competition_kernel}
\title{Compute trait-based competition coefficients from a distance matrix}
\usage{
compute_competition_kernel(
  g_all,
  residents,
  invaders = NULL,
  sigma_t = NULL,
  sigma_method = c("sd", "median", "iqr"),
  eps = 1e-08
)
}
\arguments{
\item{g_all}{matrix. Symmetric species × species \strong{trait distance} matrix
with row/column names as species IDs (e.g., from Gower).}

\item{residents}{character. Vector of resident species IDs (must be in \code{rownames(g_all)}).}

\item{invaders}{NULL or character. Vector of invader species IDs. If \code{NULL},
defaults to all species in \code{g_all} that are not in \code{residents}.}

\item{sigma_t}{NULL or numeric. Kernel bandwidth. If \code{NULL}, estimated from the
upper triangle of the resident-resident distances using \code{sigma_method}.}

\item{sigma_method}{character. How to estimate \eqn{\sigma_t} when missing; one of
\code{c("sd","median","iqr")}. Default \code{"sd"}.}

\item{eps}{numeric. Tiny positive value used if the estimated \eqn{\sigma_t} is zero;
default \code{1e-8}.}
}
\value{
A list with:
\itemize{
\item \code{d_ij} \code{(n_inv × n_res)}: invader-resident distance block (from \code{g_all}).
\item \code{a_ij} \code{(n_inv × n_res)}: competition coefficients (Gaussian kernel of distances \eqn{d_{ij}}).
\item \code{sigma_t}: bandwidth used.
\item \code{meta}: list with estimation method and counts of invaders/residents.
}
}
\description{
Given a species-by-species \strong{trait distance} matrix (e.g., Gower), this function
extracts the \strong{invader × resident} block of distances \eqn{d_{ij}} and transforms
it to a \strong{competition coefficient} matrix \eqn{a_{ij}} using a Gaussian kernel:
\deqn{a_{ij} = \exp\!\left\{ - \frac{d_{ij}^2}{2\,\sigma_t^2} \right\}.}

The kernel bandwidth \eqn{\sigma_t} controls how quickly competition decays with
trait difference. By default it is estimated from the \strong{resident-resident} distances,
so the decay reflects the realised dispersion of the resident pool.
}
\details{
\itemize{
\item Use a \strong{distance} matrix for \code{g_all} (not similarity). For Gower, distances are typically in \link{0, 1}.
\item Estimating \eqn{\sigma_t} from residents makes the kernel scale \strong{data-driven} and comparable across analyses.
\item If you prefer a fixed ecological scale, pass \code{sigma_t} explicitly (e.g., a trait threshold of interest).
}
}
\examples{
# --- Simulate a toy distance matrix (no external packages) ---
set.seed(42)
spp <- paste0("sp_", 1:8)
traits <- data.frame(
  t1 = rnorm(length(spp)),
  t2 = runif(length(spp))
)

# Euclidean distances on simulated traits, scaled to [0, 1]
g_all <- as.matrix(stats::dist(traits, method = "euclidean"))
g_all <- g_all / max(g_all)                 # scale to [0,1]
rownames(g_all) <- colnames(g_all) <- spp

# Define residents and invaders
residents <- spp[1:5]
invaders  <- spp[6:8]

# Compute competition kernel (sigma_t estimated from resident–resident distances)
comp <- compute_competition_kernel(
  g_all     = g_all,
  residents = residents,
  invaders  = invaders,
  sigma_method = "sd"
)

# Inspect results
str(comp$a_ij)           # (invaders × residents) competition coefficients
comp$sigma_t             # bandwidth used

# Same call without providing invaders (uses complement of residents)
comp2 <- compute_competition_kernel(g_all, residents = residents)

}
