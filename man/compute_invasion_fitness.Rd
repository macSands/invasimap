% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_invasion_fitness.R
\name{compute_invasion_fitness}
\alias{compute_invasion_fitness}
\title{Compute invasion fitness from competition/impact tensors and growth predictions}
\usage{
compute_invasion_fitness(
  I_raw = NULL,
  pressure_inv_site = NULL,
  r_mat = NULL,
  predictions = NULL,
  a_ij = NULL,
  Nstar = NULL,
  logistic_on = c("raw", "rel"),
  k = 1,
  x0 = NULL,
  prefer = c("logis", "rel", "raw", "scaled")
)
}
\arguments{
\item{I_raw}{3D numeric array \code{[invader, resident, site]} from \code{assemble_matrices()},
or \code{NULL} if you pass \code{pressure_inv_site} instead.}

\item{pressure_inv_site}{numeric matrix \code{[invader, site]} (sum over residents),
optional alternative to \code{I_raw}.}

\item{r_mat}{numeric matrix \code{[invader, site]} of invader growth on the response scale,
or \code{NULL} if you pass \code{predictions}.}

\item{predictions}{data.frame or \code{NULL}. Long table with columns
\code{species}, \code{site_id}, \code{pred}. Used to build \code{r_mat} if \code{r_mat} is \code{NULL}.}

\item{a_ij}{numeric matrix \code{[invader, resident]} of competition coefficients; required
only for \code{lambda_rel} or for \code{lambda_logis} when \code{logistic_on = "rel"}.}

\item{Nstar}{numeric matrix \code{[resident, site]} of resident abundances; required for \code{lambda_rel}
and for \code{lambda_logis} when \code{logistic_on = "rel"}.}

\item{logistic_on}{character. Use \code{"raw"} (default) to apply the logistic cap to \code{C_raw};
use \code{"rel"} to apply it to \code{A \%*\% N_rel}.}

\item{k}{numeric. Logistic steepness parameter (default \code{1}).}

\item{x0}{numeric or \code{NULL}. Logistic midpoint. If \code{NULL}, set to
\code{median(C_target, na.rm = TRUE)}.}

\item{prefer}{\code{"logis"}|\code{"rel"}|\code{"raw"}|\code{"scaled"}. Which fitness to return as \code{$lambda}
(default \code{"logis"}).}
}
\value{
A list with components:
\itemize{
\item \code{C_raw} \code{[invader, site]}: total penalty summed over residents.
\item \code{r_mat} \code{[invader, site]}: invader growth matrix.
\item \code{lambda_raw}, \code{lambda_scaled}, \code{lambda_rel}, \code{lambda_logis}: fitness variants.
\item \code{lambda}: the selected fitness (per \code{prefer}).
\item \code{meta}: data about inputs, dimensions, and chosen options.
}
}
\description{
Aggregates the site- and species-specific impact tensor to quantify the \strong{total
competitive penalty} experienced by each invader at each site, then computes
several invasion-fitness formulations by subtracting competition penalties from
predicted growth.
}
\details{
Let \eqn{I_{i j s}} be the per-pair impact at site \eqn{s} (e.g., from
\code{assemble_matrices()}), with invader \eqn{i}, resident \eqn{j}. The total
competition penalty at each invader-site is
\deqn{C_{i s} = \sum_{j} I_{i j s}.}
Given a matrix of invader growth predictions \eqn{r_{i s}}, we compute:
\itemize{
\item \strong{Raw:} \eqn{\lambda^{raw}_{i s} = r_{i s} - C_{i s}}.
\item \strong{Scaled:} \eqn{\lambda^{scaled}_{i s} = r_{i s} - C_{i s}/J} \,(where \eqn{J} is the number of residents).
\item \strong{Relative-abundance:} \eqn{\lambda^{rel}_{i s} = r_{i s} - (A N^{rel})_{i s}}, where
\eqn{A = [a_{i j}]} and \eqn{N^{rel}_{j s} = N_{j s} / \sum_{j'} N_{j' s}}.
\item \strong{Logistic-capped:} \eqn{\lambda^{logis}_{i s} = r_{i s} - \frac{1}{1 + \exp\{-k\, (C^{*}_{i s} - x_{0})\}}},
with \eqn{C^{*}_{i s}} taken as either \eqn{C_{i s}} (raw) or \eqn{(A N^{rel})_{i s}} (relative),
selected via \code{logistic_on = "raw"} or \code{"rel"}.
}
}
\examples{
# --- Minimal, fully simulated example (base R only) ------------------------
set.seed(123)

# IDs
invaders <- paste0("sp", 1:3)   # 3 invaders
residents <- paste0("r", 1:4)   # 4 residents
sites    <- paste0("s", 1:5)    # 5 sites

# Competition coefficients a_ij (invader × resident), e.g. from a Gaussian of
# synthetic distances. Values in (0,1].
n_i <- length(invaders); n_j <- length(residents); n_s <- length(sites)
d_ij  <- matrix(runif(n_i * n_j), nrow = n_i,
                dimnames = list(invaders, residents))
sigma <- 0.4
a_ij  <- exp(-(d_ij^2) / (2 * sigma^2))

# Resident abundances per site Nstar (resident × site), positive numbers
Nstar <- matrix(rexp(n_j * n_s, rate = 1), nrow = n_j,
                dimnames = list(residents, sites))

# Build a simple impact tensor I_raw [invader, resident, site]:
# I_ijs = a_ij * Nstar[j, s]
I_raw <- array(NA_real_, dim = c(n_i, n_j, n_s),
               dimnames = list(invaders, residents, sites))
for (s in seq_along(sites)) {
  I_raw[, , s] <- a_ij * rep(Nstar[, s], each = n_i)
}

# Predicted growth on the response scale r_mat [invader, site]
r_mat <- matrix(rexp(n_i * n_s, rate = 1), nrow = n_i,
                dimnames = list(invaders, sites))

# Compute invasion fitness (logistic cap applied to relative pressure A \%*\% N_rel)
fit <- compute_invasion_fitness(
  I_raw       = I_raw,
  r_mat       = r_mat,
  a_ij        = a_ij,
  Nstar       = Nstar,
  logistic_on = "rel",
  k           = 1,
  x0          = NULL,
  prefer      = "logis"
)

# Inspect the final fitness matrix [invader × site]
dim(fit$lambda); range(fit$lambda, na.rm = TRUE)

# Alternative variants:
# fit_raw    <- compute_invasion_fitness(I_raw = I_raw, r_mat = r_mat, prefer = "raw")
# fit_scaled <- compute_invasion_fitness(I_raw = I_raw, r_mat = r_mat, prefer = "scaled")

}
